=begin
前提

まず、この問題を素直に解く場合、与えられたnに対して
縦:n - 1, 横:1, のような格子を作成し、その経路をすべて通った時に
始点に戻ってくるかを確かめることとなる。

この時、始点に戻ってくるかどうかは、経路の通り数が偶数であるかを調べればよい。
経路の通り数は、横のセルをxと置いた時に nCx となるから、
nC1 .. nC2 .. nCx と調べていき、最初に偶数になった時のxが答えとなる。

またこの時にnが偶数の場合は必ずnC1の時点で偶数になるので答えは1となる。

よってn=奇数の時のみ上記の計算を行い、偶数の場合は1を返してやればよい。

と思ったのだが、nが99999に近くなってくると計算が1秒以内に終わらないので、別の方法を考える。

13という数字を仮に考える。この場合x=1の場合は、当然奇数になるので
x=2の場合の13/1 * 12/2 で偶数になるので2が答えになる。
11の場合はx=2でも11/1 * 10/2 で偶数にならず
x=4 のとき初めて 8/4 で偶数になる。

すなわち、分母と分子をそれぞれ素因数分解し、
分子の方が2の数が大きくなったタイミングが答えとなる。

ここでnを2進数として考える。
素因数分解した際に、いくつ2があるか、だが
2進数で2で割る、という操作をした際に1ビット右にずれることから
右から連続する0の数を数えればよい。

分母はnから(n-1),(n-2)...と1ずつ少なくなっていき
分子は1,2,3..と1ずつ増えていくなかで、分子の方が
右から連続する0の個数が多くなるタイミングを考える

こう考えると、偶数の場合は必ず0が1つ連続するので
nC1の時点で必ず偶数になり、答えが1になる。

さらに下の例を見ると、
1 ~ 8 までの動きと
15 ~ 8 までは、先頭に1が付いているか否かの違いのみで
右から連続する0の個数の推移は同じことがわかる。
すなわちn = 15の場合は値が偶数になることはなく解は0となる。
このことはすべての2のべき乗-1に言える。

10000 16
1111 15
1110 14
1101 13
1100 12
1011 11
1010 10
1001 9
1000 8
111 7
110 6
101 5
100 4
11 3
10 2
1 1

さて、ここで最後から数えて連続する1に着目すると、
その連続する1をに対して-1を繰り返し、すべて0にする試行は
-1をn回繰り返した際の分母も増え方と同一である。

例 11の場合
2進数で1011なので、連続する1に着目し11を0にすることを考える
これを0にする際の操作は、
分子:1011 -> 1010 -> 1001
分母:1 -> 10 -> 11
分子の10を無視すると、順番は違えど、全く同じ操作をしていることがわかる。
また、後ろから数えた場合の0の増減も仕方も同一である。

すなわち、連続する1を0にする過程においては、分子の0の数が分母を上回ることは起き得ない。

よって、一つずつ減らして行った時に、0の個数が分母よりも増えるタイミングは
2進数で表したnにすでに存在する0の場所まで-1を繰り返し、0がくっついたタイミングである。

よって
nを2進数で表した際に、後ろから数えて最初に現れた0の位置を調べ、
そこまでがすべて0になるまで-1を繰り返した際の試行回数が答えとなる。
0の位置をzと置いた場合、2進数なので、そこまでの試行回数は 2のzとなるのでそれを求めればよい。

先ほど記述した2のべき乗-1の場合は2進数で表した場合に0が存在しないので答えは0となる。
=end

n = STDIN.gets.chomp.to_i
# n = 98303

# 与えられた数字を二進数のStringに変換する
binary_digits = n.to_s(2)

# 後ろから数えて何番目に0があるかを調べる。すべて1の場合（2のべき乗-1 の場合）はnilとなる
location_zero_from_end = binary_digits.reverse.index('0')

puts location_zero_from_end.nil? ? 0 : 2 ** location_zero_from_end
